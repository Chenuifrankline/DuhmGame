package codegenerator.templates

import codegenerator.CodegenInterface
import codegenerator.Template
import java.nio.file.Path
import java.nio.file.Paths
import java.util.HashSet
import java.util.LinkedList
import org.eclipse.uml2.uml.Class
import org.eclipse.uml2.uml.NamedElement
import org.eclipse.uml2.uml.Type
import org.eclipse.uml2.uml.PrimitiveType
import org.eclipse.uml2.uml.Enumeration
import org.eclipse.uml2.uml.Dependency
import org.eclipse.uml2.uml.InstanceSpecification
import org.eclipse.uml2.uml.Artifact

class ClassTemplate implements Template<Class> {

	override String generateCode(CodegenInterface it, Class umlClass, String context) {
		// TODO: Aufgabe 3
		switch (context) {
			case "declaration": genH(it, umlClass)
			case "implementation": genC(it, umlClass)
			default: '''unbekannter Kontext «context»'''
		}

	}

	def String genC(CodegenInterface it, Class umlClass) {
		val className = umlClass?.name

		val instances = umlClass.model?.packagedElements?.filter(InstanceSpecification)?.filter [ i |
			i.classifiers.size == 1 && i.classifiers.head == umlClass
		]

		val instanceDefs = instances?.map [ i |
			val typeName = generate(umlClass, "name")
			val instanceName = generate(i, "name")

			val slotInits = i.slots.map [ slot |
				val attr = slot.definingFeature
				val attrName = attr?.name

				if (attrName === null || slot.values.empty) {
					return null
				}

				if (slot.values.size > 1) {
					val valueList = slot.values.map[v|generate(v, "value")]
					'''	.«attrName» = {
		«valueList.join(",\n")»
	}'''
				} else {
					val singleValue = generate(slot.values.head, "value")
					'''	.«attrName» = «singleValue»'''
				}
			]

			if (slotInits.empty) {
				'''«typeName» «instanceName» = {
};'''
			} else {
				'''«typeName» «instanceName» = {
«slotInits.join(",\n")»
};'''
			}
		]

		val operations = umlClass.ownedOperations.map [ op |
			generate(op, "implementation")
		]

		return '''
			#include "«className».h"
			
			«operations.join("\n\n")»
			«IF instanceDefs !== null && !instanceDefs.empty»
				«instanceDefs.join("\n\n")»
			«ENDIF»
		'''
	}

	def String genH(CodegenInterface it, Class umlClass) {
		val packageName = if(umlClass.package !== null) generate(umlClass.package, "name") + "_" else ""
		val className = (packageName + umlClass.name).toUpperCase
		val structCode = generate(umlClass, "typedefinition")
		val includes = generateIncludes(it, umlClass).trim

		val instances = umlClass.model?.packagedElements?.filter(InstanceSpecification)?.filter [ i |
			i.classifiers.size == 1 && i.classifiers.head == umlClass
		]

		val operations = umlClass.ownedOperations.map [ op |
			generate(op, "declaration")
		]

		val instanceDecls = instances?.map [ i |
			val classTypeName = generate(umlClass, "name")
			val instanceName = generate(i, "name")
			'''extern «classTypeName» «instanceName»;'''
		]

		return '''
#ifndef «className»_H
#define «className»_H
«IF !includes.empty»

«includes»
«ENDIF»

«structCode»«IF !operations.empty»

«operations.join("\n\n")»
«ENDIF»

«IF instanceDecls !== null && !instanceDecls.empty»
«instanceDecls.join("\n")»

«ENDIF»
#endif
'''
	}

	def String generateIncludes(CodegenInterface it, Class umlClass) {
		val types = new HashSet<Type>()
		val artifacts = new HashSet<Artifact>()

		for (property : umlClass.ownedAttributes) {
			if (property.type !== null && !(property.type instanceof PrimitiveType) && property.type !== umlClass) {
				if (property.type instanceof Class || property.type instanceof Enumeration) {
					types.add(property.type)
				} else if (property.type instanceof Artifact) {
					artifacts.add(property.type as Artifact)
				}
			}
		}
		// In generateIncludes method, make sure custom types are being included
		for (property : umlClass.ownedAttributes) {
			if (property.type !== null && !(property.type instanceof PrimitiveType) && property.type !== umlClass) {
				if (property.type instanceof Class || property.type instanceof Enumeration) {
					types.add(property.type)
				} else if (property.type instanceof Artifact) {
					artifacts.add(property.type as Artifact)
				}
			}
		}

		for (operation : umlClass.ownedOperations) {
			if (operation.type !== null && !(operation.type instanceof PrimitiveType) && operation.type !== umlClass) {
				if (operation.type instanceof Class || operation.type instanceof Enumeration) {
					types.add(operation.type)
				} else if (operation.type instanceof Artifact) {
					artifacts.add(operation.type as Artifact)
				}
			}

			for (parameter : operation.ownedParameters) {
				if (parameter.type !== null && !(parameter.type instanceof PrimitiveType) &&
					parameter.type !== umlClass) {
					if (parameter.type instanceof Class || parameter.type instanceof Enumeration) {
						types.add(parameter.type)
					} else if (parameter.type instanceof Artifact) {
						artifacts.add(parameter.type as Artifact)
					}
				}
			}
		}

		for (rel : umlClass.relationships.filter(Dependency)) {
			val dep = rel as Dependency
			for (supplier : dep.suppliers) {
				if (supplier instanceof Class || supplier instanceof Enumeration) {
					types.add(supplier as Type)
				} else if (supplier instanceof Artifact) {
					artifacts.add(supplier as Artifact)
				}
			}
		}

		val sortedIncludePaths = types.map[type|generatePath(it, umlClass, type)].filter [ p |
			p !== null && !p.startsWith("ERROR_PATH_NOT_FOUND")
		].sort

		val artifactIncludes = artifacts.map[a|generate(a, "include")].filter[inc|inc !== null].sort

		'''
			«FOR pathString : sortedIncludePaths AFTER '\n'»
				#include "«pathString»"
			«ENDFOR»
			«FOR inc : artifactIncludes AFTER '\n'»
				«inc»
			«ENDFOR»
		'''
	}

	/*
	 * 
	 * 
	 * 
	 * 
	 * 	def String generateIncludes(CodegenInterface it, Class umlClass) {
	 * 		val types = new HashSet<Type>()

	 *         for (property : umlClass.ownedAttributes) {
	 *             if (property.type !== null && !(property.type instanceof PrimitiveType) && property.type !== umlClass) {
	 *                 if (property.type instanceof Class || property.type instanceof Enumeration) {
	 *                      types.add(property.type)
	 *                 }
	 *             }
	 *         }

	 *         for (operation : umlClass.ownedOperations) {
	 *             if (operation.type !== null && !(operation.type instanceof PrimitiveType) && operation.type !== umlClass) {
	 *                  if (operation.type instanceof Class || operation.type instanceof Enumeration) { 
	 *                     types.add(operation.type)
	 *                 }
	 *             }
	 *             for (parameter : operation.ownedParameters) {
	 *                 if (parameter.type !== null && !(parameter.type instanceof PrimitiveType) && parameter.type !== umlClass) {
	 *                     if (parameter.type instanceof Class || parameter.type instanceof Enumeration) {
	 *                         types.add(parameter.type)
	 *                     }
	 *                 }
	 *             }
	 *         }
	 *         
	 *         for (rel : umlClass.relationships.filter(Dependency)) {
	 *     val dep = rel as Dependency 
	 *     for (supplier : dep.suppliers) {
	 *         if (supplier instanceof Class || supplier instanceof Enumeration) {
	 *             types.add(supplier as Type)
	 *         }
	 *     }
	 * }
	 * 		
	 * 		        val sortedIncludePaths = types.map[type |generatePath(it, umlClass, type)  ]
	 * 		        .filter[p | p !== null && !p.startsWith("ERROR_PATH_NOT_FOUND")].sort 
	 * 		       

	 *         '''
	 *             «FOR pathString : sortedIncludePaths AFTER '\n'»
	 *                 #include "«pathString»"
	 *             «ENDFOR»
	 *         '''

	 * 	
	 * 	}
	 */
	def generatePath(CodegenInterface it, NamedElement from, NamedElement to) {
		val fromPath = getPath(from, "declaration")
		val toPath = getPath(to, "declaration")

		val relPath = fromPath.parent?.relativize(toPath) ?: toPath
		return relPath.join("/")
	}

	override Path getPath(Class umlClass, String context) {
		var path = new LinkedList<String>()
		switch context {
			case "declaration": {
				path.addFirst(umlClass.name + ".h")
			}
			case "implementation": {
				path.addFirst(umlClass.name + ".c")
			}
			default:
				return null
		}
		var parent = umlClass.namespace
		while (null !== parent) {
			path.addFirst(parent.name)
			parent = parent.namespace
		}
		return Paths.get(path.head, path.tail)
	}
}
