package codegenerator.templates

import codegenerator.CodegenInterface
import codegenerator.Template
import java.nio.file.Path
import java.nio.file.Paths
import java.util.HashSet
import java.util.LinkedList
import org.eclipse.uml2.uml.Class
import org.eclipse.uml2.uml.NamedElement
import org.eclipse.uml2.uml.Type
import java.util.Enumeration

class ClassTemplate implements Template<Class> {

	override String generateCode(CodegenInterface it, Class umlClass, String context) {
		// TODO: Aufgabe 3
		switch (context) {
			case "declaration":
				genH(it, umlClass)
			case "implementation":
				genC(it, umlClass)
			default: '''unbekannter Kontext «context»'''
		}

	}

	def genC(CodegenInterface it, Class umlClass) {
		
		throw new UnsupportedOperationException("TODO: auto-generated method stub")
	}

	def genH(CodegenInterface it, Class umlClass) {
		throw new UnsupportedOperationException("TODO: auto-generated method stub")
	}



	def String generateIncludes(CodegenInterface it, Class umlClass) {
		val types = new HashSet<String>()

// Durchsuchen der Attribute nach Klassen- oder Enumerationstypen
		for (property : umlClass.ownedAttributes) {
			if (property.type instanceof Class || property.type instanceof Enumeration) {
				types.add(generatePath(umlClass, property.type))
			}
		}


// Durchsuchen der Operationen nach Klassen- oder Enumerationstypen
		for (operation : umlClass.ownedOperations) {
			for (parameter : operation.ownedParameters) {
				if (parameter.type instanceof Class || parameter.type instanceof Enumeration) {
					types.add(generatePath(umlClass,parameter.type))
				}
			}
		}
		
		// Durchsuchen der Klassenabhängigkeiten nach Klassen- oder Enumerationstypen
		for (clients : umlClass.clientDependencies) {
			for (supplier : clients.suppliers.filter(Type)) {
				if (supplier instanceof Class || supplier instanceof Enumeration) {
					types.add(generatePath(umlClass, supplier))
				}
			}
		}
		

		'''
			«FOR type : types.sort() AFTER '\n'»
				#include "«type»"
			«ENDFOR»
		'''
	}


	def generatePath(CodegenInterface it, NamedElement from, NamedElement to) {
		val fromPath = getPath(from, "declaration")
		val toPath = getPath(to, "declaration")

		val relPath = fromPath.parent?.relativize(toPath) ?: toPath
		return relPath.join("/")
	}

	override Path getPath(Class umlClass, String context) {
		var path = new LinkedList<String>()
		switch context {
			case "declaration": {
				path.addFirst(umlClass.name + ".h")
			}
			case "implementation": {
				path.addFirst(umlClass.name + ".c")
			}
			default:
				return null
		}
		var parent = umlClass.namespace
		while (null !== parent) {
			path.addFirst(parent.name)
			parent = parent.namespace
		}
		return Paths.get(path.head, path.tail)
	}
}
